<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.aldebaran-robotics.com/schema/choregraphe/project.xsd" xar_version="3">
    <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0">
        <bitmap>media/images/box/root.png</bitmap>
        <script language="4">
            <content>
                <![CDATA[]]>
</content>
        </script>
        <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
        <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
        <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
        <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
        <Timeline enable="0">
            <BehaviorLayer name="behavior_layer1">
                <BehaviorKeyframe name="keyframe1" index="1">
                    <Diagram>
                        <Box name="secondHit " id="1" localization="8" tooltip="" x="1046" y="189">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="18" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="18" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="18" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="18" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="18" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="18" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="18" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="18" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="18" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="18" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="around_the_ball" id="2" localization="8" tooltip="" x="737" y="206">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_camera = 0
        self.head_angles = ["HeadYaw", "HeadPitch"]
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxsteptheta],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            nameID = None
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except (TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            #self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > 15):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def get_Pole_pixel(image):
            final_h = 0.0
            final_x = 0.0
            final_y = 0.0
            final_w = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                x, y, w, h = cv2.boundingRect(c)
                if(h > final_h):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            if(final_h < 120):
                return 0, 0
            else:
                return final_x + final_w/2.0, final_h + final_y
        def get_distance(image_x, image_y):
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            head_pitch = body_angles[1]
            if self.active_camera == 0:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.203680") - Decimal(str(image_y - 480.0))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.top_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = Decimal(str(image_x - 640.0)) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.top_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            elif self.active_camera == 1:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.86155206") - (Decimal(str(image_y)) - Decimal("480.0"))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.bottom_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = (Decimal(str(image_x)) - Decimal("640.0")) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.bottom_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            return distance_x , distance_y

        #置手部动作
        time.sleep(1)
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.1)

        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.active_camera = 0
            pole_x = 0.0
            pole_y = 0.0
            pole_flag = 0
            turn_flag = 0
            while(pole_x == 0.0 and pole_y == 0.0):
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    break
                head_yaw = (pole_flag/2) * 20 * math.pow(-1, int(math.fabs(pole_flag))) + 0.0
                if(head_yaw > 90):
                    head_yaw = 90
                    turn_flag = 1
                elif(head_yaw < -90):
                    head_yaw = -90
                    turn_flag = 0
                self.motion.setAngles(self.head_angles, [head_yaw/180.0*math.pi,0], 0.1)
                time.sleep(6)
                self.active_camera, image = get_Image(self.active_camera)
                pole_x, pole_y = get_Pole_pixel(image)
                self.output((pole_x, pole_y))
                if(turn_flag == 0):
                    pole_flag = pole_flag + 1
                elif(turn_flag == 1):
                    pole_flag = pole_flag - 1
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            turn_angle = int((-head_yaw / math.pi *180.0 + (pole_x - 640.0) / 1280.0 * 60 + 60) / 1.9)
            self.output(turn_angle)
            flag = 0

            if(turn_angle <= 20):
                self.motion.setAngles(self.head_angles, [0, 0], 0.1)
                self.motion.move(0,0,0.03, self.moveConfig)
                time.sleep(20)
                self.motion.move(0,0,0, self.moveConfig)
                while(1):
                    self.active_camera = 0
                    self.active_camera, image = get_Image(self.active_camera)
                    pole_x , pole_y = get_Pole_pixel(image)
                    if(pole_x != 0 and pole_x < 800):
                        break
                    self.motion.move(0.0,0.0,-0.03,self.moveConfig)
                    time.sleep(4)
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.onStopped()
                break
            elif(turn_angle > 20):
                turn_angle = 15
            #右手不动
            leftArmEnable  = True
            rightArmEnable = False
            self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)
            self.motion.setAngles(self.head_angles, [0, 0], 0.1)
            while(1):
                self.output(turn_angle)
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    self.motion.move(0.0, 0.0, 0.0, self.moveConfig)
                    self.stop_run()
                    break

                red_ball_x = 0.0
                red_ball_y = 0.0
                red_ball_radius = 0.0
                red_ball_distance_x = Decimal('0.0')
                red_ball_distance_y = Decimal('0.0')

                self.active_camera = 1
                self.active_camera, image = get_Image(self.active_camera)
                red_ball_x, red_ball_y = get_Redball_pixel(image)
                red_ball_distance_x, red_ball_distance_y = get_distance(red_ball_x, red_ball_y)
                turn_angle = turn_angle - 1
                if(red_ball_x ==0 and red_ball_y == 0):
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[-0.15, 0.0
    , 0], [0, 0, 0]], [0.3,0.3],False)
                    continue
                elif(red_ball_x > 1000):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0.0, 0.0
    , -0.15], [0, 0, 0]], [0.3,0.3],False)
                    continue
                control_x = 0.001
                control_y = 0.01
                control_theta = 0.03
                red_ball_distance_x = float(red_ball_distance_x)
                red_ball_distance_y = float(red_ball_distance_y)
                theta = math.atan(red_ball_distance_x/red_ball_distance_y)
                control_theta = control_theta + round(theta/0.1) * 0.003
                distance = math.sqrt(red_ball_distance_y*red_ball_distance_y + red_ball_distance_x*red_ball_distance_x)
                if(flag == 0):
                    expect_radius = distance
                    flag = 1
                diff_radius = distance - expect_radius
                control_x = control_x + round(diff_radius/5.0) * 0.001
                if(turn_angle > 0 and theta >= -0.2):
                    self.motion.move(control_x, control_y, -control_theta, self.moveConfig)
                elif(turn_angle > 0 and theta < -0.2):
                    self.motion.move(control_x, control_y, control_theta, self.moveConfig)
                else:
                    self.motion.move(0,0,0,self.moveConfig)
                    time.sleep(2)
                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="Bumpers_first" id="3" localization="8" tooltip="Listen to bumpers sensors. Stimulate onLeft or onRight output depending on&#x0A;which bumper is stimulated." x="208" y="197">
                            <bitmap>media/images/box/movement/move_foot.png</bitmap>
                            <bitmap>media/images/box/movement/move_leftfoot.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload()
            self.onStopped()]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Input name="LeftBumperPressed" type="0" type_size="1" nature="4" stm_value_name="LeftBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" />
                            <Input name="RightBumperPressed" type="0" type_size="1" nature="4" stm_value_name="RightBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="6" />
                            <Output name="onLeft" type="1" type_size="1" nature="2" inner="0" tooltip="When left bumper is stimulated." id="7" />
                            <Output name="onRight" type="1" type_size="1" nature="2" inner="0" tooltip="When right bumper is stimulated." id="8" />
                            <Timeline enable="0">
                                <BehaviorLayer name="behavior_layer1">
                                    <BehaviorKeyframe name="keyframe1" index="1">
                                        <Diagram>
                                            <Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="196" y="61">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Box name="If &gt; 0" id="4" localization="8" tooltip="Transmit only if value is &gt; 0." x="197" y="165">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="4" />
                                            <Link inputowner="0" indexofinput="7" outputowner="2" indexofoutput="3" />
                                            <Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="5" />
                                            <Link inputowner="0" indexofinput="8" outputowner="4" indexofoutput="3" />
                                        </Diagram>
                                    </BehaviorKeyframe>
                                </BehaviorLayer>
                            </Timeline>
                        </Box>
                        <Box name="go_to_ball  " id="8" localization="8" tooltip="" x="565" y="192">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import cv2
from PIL import Image
import vision_definitions
import numpy as np
import math
import time
import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.memory = ALProxy("ALMemory")

        self.head_angles = ['HeadYaw', 'HeadPitch']
        self.active_camera = 0

        maxstepx = 0.06
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.25
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                           ["MaxStepY", maxstepy],
                           ["MaxStepTheta", maxsteptheta],
                           ["MaxStepTheta",maxstepfrequency],
                           ["StepHeight", stepheight],
                           ["TorsoWx", torsowx],
                           ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            if(self.active_camera == 0):
                min_radius = 5.0
            elif(self.active_camera == 1):
                min_radius = 15.0
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > min_radius):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def one_Step( onestep_x, onestep_y, onestep_theta, onestep_count):
            onestep_X = onestep_x
            if onestep_theta == 0.0:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.04
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.04
            else:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.06
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.06
            onestep_Theta = onestep_theta
            onestep_Count = onestep_count
            lname = "LAnklePitch"
            lframe = 0
            leftFootPosition = self.motion.getPosition(lname, lframe, True)
            rname = "RAnklePitch"
            rframe = 0
            rightFootPosition = self.motion.getPosition(rname, rframe, True)
            stepDelta_x = leftFootPosition[0] - rightFootPosition[0]
            stepDelta_y = leftFootPosition[1] - rightFootPosition[1]
            if onestep_Theta == 0:
                if onestep_X > 0:
                    if stepDelta_x > 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x <=0 :
                        legName = ["LLeg", "RLeg"]
                elif onestep_X <= 0:
                    if stepDelta_x < 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x >=0:
                        legName = ["LLeg", "RLeg"]
            elif onestep_Theta > 0:
                legName = ["LLeg", "RLeg"]
            elif onestep_Theta < 0:
                legName = ["RLeg", "LLeg"]
            for i in range(0,onestep_Count):
                footSteps = [[onestep_X, onestep_Y, onestep_Theta], [onestep_X, -onestep_Y, onestep_Theta]]
                fractionMaxSpeed = [0.4, 0.4]
                clearExisting = False
                self.motion.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)
            self.motion.waitUntilMoveIsFinished()
            leftFootPosition_1 = self.motion.getPosition("LAnklePitch", 0, True)
            rightFootPosition_1 = self.motion.getPosition("RAnklePitch", 0, True)
            stepDelta_x_1 = leftFootPosition_1[0] - rightFootPosition_1[0]
            MaxSpeed = 0.2
            if (stepDelta_x_1 > 0):
                self.motion.setFootStepsWithSpeed(['RLeg'], [[0, 0, 0]], [MaxSpeed],False)
            elif (stepDelta_x_1 < 0):
                self.motion.setFootStepsWithSpeed(['LLeg'], [[0, 0, 0]], [MaxSpeed],False)
            time.sleep(0.1)
        def go_Right_angle(red_ball_x, red_ball_y):
            flag = 0
            if(self.active_camera == 0 and red_ball_y < 700):
                flag = 0
            elif(self.active_camera == 0 and red_ball_y >= 700):
                flag = 1
            elif(self.active_camera == 1):
                flag = 2
            pixel = ((580, 720), (530,770,), (600, 700))
            if red_ball_x <= pixel[flag][0]:
                if red_ball_x <= 400:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x <= 520:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x > 520:
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
            elif red_ball_x >= pixel[flag][1]:
                if red_ball_x >= 900:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x >= 780:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x < 780:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        self.motion.moveInit()
        self.motion.setAngles(self.head_angles, [0,0], 0.1)
        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0,0,0,self.moveConfig)
                self.stop_run()
                break
            red_ball_x = 0.0
            red_ball_y = 0.0
            self.active_camera, image = get_Image(self.active_camera)
            red_ball_x, red_ball_y = get_Redball_pixel(image)
            self.output((red_ball_x, red_ball_y))
            if(red_ball_x == 0 and red_ball_y == 0):
                continue
            if(self.active_camera == 0):
                if(red_ball_y < 700):
                    if(red_ball_x > 580 and red_ball_x < 720):
                        if red_ball_y < 650:
                            if red_ball_x > 620 and red_ball_x < 680:
                                self.motion.move(0.06,0, 0, self.moveConfig)
                                time.sleep(6)
                                self.motion.move(0,0,0,self.moveConfig)
                            else:
                                self.motion.move(0.06,0,0,self.moveConfig)
                                time.sleep(4)
                                self.motion.move(0,0,0,self.moveConfig)
                        elif red_ball_y >= 650 and red_ball_y <700:
                            self.motion.move(0.04,0.0,0.0,self.moveConfig)
                            time.sleep(4)
                            self.motion.move(0,0,0,self.moveConfig)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >=700 and red_ball_y < 800):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 700 and red_ball_y < 760:
                            one_Step(0.04,0,0,3)
                        elif red_ball_y >= 760 and red_ball_y <800:
                            one_Step(0.04,0,0,2)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >= 800 and red_ball_y < 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 800 and red_ball_y <= 830:
                            one_Step(0.03,0.0,0.0,2)
                        elif  red_ball_y >830 and red_ball_y <900:
                            one_Step(0.04,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif (red_ball_y >= 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        self.active_camera = 1
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
            elif(self.active_camera == 1):
                if(red_ball_y < 600):
                    if(red_ball_x > 600 and red_ball_x < 700):
                        if red_ball_y <200:
                            one_Step(0.04,0.0,0.0,3)
                        elif red_ball_y >= 200 and red_ball_y <330:
                            one_Step(0.03,0.0,0.0,3)
                        elif red_ball_y >= 330 and red_ball_y <500:
                            one_Step(0.03,0.0,0.0,2)
                        elif red_ball_y >= 500 and red_ball_y <600:
                            one_Step(0.03,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif red_ball_y >= 500:
                    if red_ball_x <= 500:
                        one_Step(0, 0, 3*math.pi/180,1)
                    elif red_ball_x >= 780:
                        one_Step(0, 0, -3*math.pi/180,1)
                    elif red_ball_x > 500 and red_ball_x <= 780:
                        self.onStopped()
                        break
            time.sleep(0.5)
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="hit_ready  " id="10" localization="8" tooltip="" x="892" y="199">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import cv2.cv as cv
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_Camera = 0
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')
        self.head_angles = ["HeadYaw", "HeadPitch"]

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxstepy],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        #转换摄像头,参数:"Top", "Bottom"
        def select_Camera(camera_Name):
            if camera_Name == "Top":
                active_Camera = 0
            elif camera_Name == "Bottom":
                active_Camera = 1
            else:
                return 0
            self.device.setActiveCamera(active_Camera)
            nameID = self.device.subscribe("python_GA"+str(random.randint(100,100000)), vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            return active_Camera, nameID
        def get_Image(nameID):
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    img = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(img)
            return frame

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        #右手不动
        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        pole_x = 0.0
        pole_y = 0.0
        pole_distance_x = 0.0
        pole_distance_y = 0.0
        red_ball_x = 0.0
        red_ball_y = 0.0
        red_ball_distance_x = 0.0
        red_ball_distance_y = 0.0
        head_yaw_init = -30*math.pi/180
        head_pitch_init = 10*math.pi/180
        MaxSpeed = 0.3

        while(1):
            red_ball_x = 0.0
            red_ball_y = 0.0
            circles = None
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.motion.setAngles(self.head_angles, [head_yaw_init, head_pitch_init], 0.1)
            #获得电机角度
            body_angles = self.motion.getAngles("Body", True)
            head_yaw = Decimal((str)(body_angles[0]))
            head_pitch =Decimal((str)( body_angles[1]))
            #识别红球图像中位置
            self.active_Camera, nameID = select_Camera("Bottom")
            self.output(nameID)
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            img0 = cv2.Canny(hsv, 200, 300)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(img0, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if y > red_ball_y and radius > 15:
                    red_ball_y = y
                    red_ball_x = x
            self.output((red_ball_x, red_ball_y))
            time.sleep(0.1)

            red_ball_angle_y = Decimal((str)(math.pi/2.0)) - Decimal('0.86155206') - (Decimal((str)(red_ball_y)) - Decimal('480.0'))/Decimal('960.0') * Decimal('0.831475') - head_pitch
            red_ball_photo_distance_y = self.bottom_camera_height * Decimal((str)(math.tan(red_ball_angle_y)))
            red_ball_angle_x = (Decimal((str)(red_ball_x)) - Decimal('640.0')) / Decimal('1280.0') * Decimal('1.064127')
            red_ball_photo_distance_x = self.bottom_camera_height/Decimal((str)(math.cos(red_ball_angle_y)))*Decimal((str)(math.tan(red_ball_angle_x)))
            red_ball_distance_y = red_ball_photo_distance_y * Decimal((str)(math.cos(head_yaw))) + red_ball_photo_distance_x * Decimal((str)(math.sin(head_yaw)))
            red_ball_distance_x = red_ball_photo_distance_x * Decimal((str)(math.cos(head_yaw))) - red_ball_photo_distance_y * Decimal((str)(math.sin(head_yaw)))

            #识别杆的位置
            self.active_Camera, nameID = select_Camera("Top")
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            final_h = 0
            final_x = 0
            final_y = 0
            final_w = 0
            for c in contours:
                x,y,w,h = cv2.boundingRect(c)
                if(h>final_h and h > 120):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            pole_x = final_x + final_w / 2.0
            pole_y = final_y + final_h
            self.output((pole_x, pole_y))
            time.sleep(0.1)

            if(red_ball_x == 0 and red_ball_y == 0):
                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(pole_x >550):
                i = 5
                while i > 0:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
                    i = i-1
            elif(red_ball_y <= 730 ):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y >= 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y > 730 and red_ball_y < 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.11
, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x <= 990):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.0, 0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(pole_x <= 30):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(3)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(pole_x < 100):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(2)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(red_ball_x< 1110 and red_ball_x > 990):
                    if(pole_y >= (1.8502 * pole_x +8.0086)):
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y <= (1.6596 * pole_x -110.4816)):
                        self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y > (1.6596 * pole_x -83.4816) and pole_y < (1.8502 * pole_x + 8.0086)):
                        if(red_ball_y <= 850):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >= 930):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >850 and red_ball_y <930):
                            if(red_ball_x >= 1065):
                                self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x <= 1000):
                                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0.11, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x > 1000 and red_ball_x <1065):
                                if(pole_y >= (1.7917 * pole_x -17.7646)):
                                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                elif(pole_y <= (1.7341 * pole_x -97.7361 )):
                                    self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                else:
                                    self.onStopped()
                                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="firstHit" id="12" localization="8" tooltip="" x="406" y="186">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="31" value="0" />
                                        <Key frame="60" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="31" value="-57.8135" />
                                        <Key frame="60" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="31" value="-79.1085" />
                                        <Key frame="60" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="31" value="0.257813" />
                                        <Key frame="60" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="31" value="80.7271" />
                                        <Key frame="60" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="60" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="31" value="0.228838" />
                                        <Key frame="60" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="31" value="47.7646" />
                                        <Key frame="60" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="31" value="116.9" />
                                        <Key frame="60" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="31" value="0" />
                                        <Key frame="60" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="60" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="31" value="69.6" />
                                        <Key frame="60" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="31" value="-3" />
                                        <Key frame="60" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="31" value="-32.4" />
                                        <Key frame="60" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="secondHit  (1)" id="5" localization="8" tooltip="" x="1066" y="298">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="18" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="18" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="18" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="18" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="18" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="18" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="18" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="18" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="18" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="18" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="around_the_ball (1)" id="6" localization="8" tooltip="" x="743" y="339">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_camera = 0
        self.head_angles = ["HeadYaw", "HeadPitch"]
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxsteptheta],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            nameID = None
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except (TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            #self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > 15):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def get_Pole_pixel(image):
            final_h = 0.0
            final_x = 0.0
            final_y = 0.0
            final_w = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                x, y, w, h = cv2.boundingRect(c)
                if(h > final_h):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            if(final_h < 120):
                return 0, 0
            else:
                return final_x + final_w/2.0, final_h + final_y
        def get_distance(image_x, image_y):
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            head_pitch = body_angles[1]
            if self.active_camera == 0:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.203680") - Decimal(str(image_y - 480.0))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.top_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = Decimal(str(image_x - 640.0)) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.top_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            elif self.active_camera == 1:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.86155206") - (Decimal(str(image_y)) - Decimal("480.0"))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.bottom_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = (Decimal(str(image_x)) - Decimal("640.0")) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.bottom_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            return distance_x , distance_y

        #置手部动作
        time.sleep(1)
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.1)

        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.active_camera = 0
            pole_x = 0.0
            pole_y = 0.0
            pole_flag = 0
            turn_flag = 0
            while(pole_x == 0.0 and pole_y == 0.0):
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    break
                head_yaw = (pole_flag/2) * 20 * math.pow(-1, int(math.fabs(pole_flag))) + 0.0
                if(head_yaw > 90):
                    head_yaw = 90
                    turn_flag = 1
                elif(head_yaw < -90):
                    head_yaw = -90
                    turn_flag = 0
                self.motion.setAngles(self.head_angles, [head_yaw/180.0*math.pi,0], 0.1)
                time.sleep(6)
                self.active_camera, image = get_Image(self.active_camera)
                pole_x, pole_y = get_Pole_pixel(image)
                self.output((pole_x, pole_y))
                if(turn_flag == 0):
                    pole_flag = pole_flag + 1
                elif(turn_flag == 1):
                    pole_flag = pole_flag - 1
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            turn_angle = int((-head_yaw / math.pi *180.0 + (pole_x - 640.0) / 1280.0 * 60 + 60) / 1.9)
            self.output(turn_angle)
            flag = 0

            if(turn_angle <= 20):
                self.motion.setAngles(self.head_angles, [0, 0], 0.1)
                self.motion.move(0,0,0.03, self.moveConfig)
                time.sleep(20)
                self.motion.move(0,0,0, self.moveConfig)
                while(1):
                    self.active_camera = 0
                    self.active_camera, image = get_Image(self.active_camera)
                    pole_x , pole_y = get_Pole_pixel(image)
                    if(pole_x != 0 and pole_x < 800):
                        break
                    self.motion.move(0.0,0.0,-0.03,self.moveConfig)
                    time.sleep(4)
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.onStopped()
                break
            elif(turn_angle > 20):
                turn_angle = 15
            #右手不动
            leftArmEnable  = True
            rightArmEnable = False
            self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)
            self.motion.setAngles(self.head_angles, [0, 0], 0.1)
            while(1):
                self.output(turn_angle)
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    self.motion.move(0.0, 0.0, 0.0, self.moveConfig)
                    self.stop_run()
                    break

                red_ball_x = 0.0
                red_ball_y = 0.0
                red_ball_radius = 0.0
                red_ball_distance_x = Decimal('0.0')
                red_ball_distance_y = Decimal('0.0')

                self.active_camera = 1
                self.active_camera, image = get_Image(self.active_camera)
                red_ball_x, red_ball_y = get_Redball_pixel(image)
                red_ball_distance_x, red_ball_distance_y = get_distance(red_ball_x, red_ball_y)
                turn_angle = turn_angle - 1
                if(red_ball_x ==0 and red_ball_y == 0):
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[-0.15, 0.0
    , 0], [0, 0, 0]], [0.3,0.3],False)
                    continue
                elif(red_ball_x > 1000):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0.0, 0.0
    , -0.15], [0, 0, 0]], [0.3,0.3],False)
                    continue
                control_x = 0.001
                control_y = 0.01
                control_theta = 0.03
                red_ball_distance_x = float(red_ball_distance_x)
                red_ball_distance_y = float(red_ball_distance_y)
                theta = math.atan(red_ball_distance_x/red_ball_distance_y)
                control_theta = control_theta + round(theta/0.1) * 0.003
                distance = math.sqrt(red_ball_distance_y*red_ball_distance_y + red_ball_distance_x*red_ball_distance_x)
                if(flag == 0):
                    expect_radius = distance
                    flag = 1
                diff_radius = distance - expect_radius
                control_x = control_x + round(diff_radius/5.0) * 0.001
                if(turn_angle > 0 and theta >= -0.2):
                    self.motion.move(control_x, control_y, -control_theta, self.moveConfig)
                elif(turn_angle > 0 and theta < -0.2):
                    self.motion.move(control_x, control_y, control_theta, self.moveConfig)
                else:
                    self.motion.move(0,0,0,self.moveConfig)
                    time.sleep(2)
                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="Bumpers_second" id="7" localization="8" tooltip="Listen to bumpers sensors. Stimulate onLeft or onRight output depending on&#x0A;which bumper is stimulated." x="238" y="295">
                            <bitmap>media/images/box/movement/move_foot.png</bitmap>
                            <bitmap>media/images/box/movement/move_leftfoot.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload()
            self.onStopped()]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Input name="LeftBumperPressed" type="0" type_size="1" nature="4" stm_value_name="LeftBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" />
                            <Input name="RightBumperPressed" type="0" type_size="1" nature="4" stm_value_name="RightBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="6" />
                            <Output name="onLeft" type="1" type_size="1" nature="2" inner="0" tooltip="When left bumper is stimulated." id="7" />
                            <Output name="onRight" type="1" type_size="1" nature="2" inner="0" tooltip="When right bumper is stimulated." id="8" />
                            <Timeline enable="0">
                                <BehaviorLayer name="behavior_layer1">
                                    <BehaviorKeyframe name="keyframe1" index="1">
                                        <Diagram>
                                            <Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="196" y="61">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Box name="If &gt; 0" id="4" localization="8" tooltip="Transmit only if value is &gt; 0." x="197" y="165">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="4" />
                                            <Link inputowner="0" indexofinput="7" outputowner="2" indexofoutput="3" />
                                            <Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="5" />
                                            <Link inputowner="0" indexofinput="8" outputowner="4" indexofoutput="3" />
                                        </Diagram>
                                    </BehaviorKeyframe>
                                </BehaviorLayer>
                            </Timeline>
                        </Box>
                        <Box name="firstHit (1)" id="13" localization="8" tooltip="" x="423" y="295">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="24" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="24" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="24" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="24" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="24" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="24" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="24" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="24" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="24" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="24" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="24" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="24" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="secondHit  (2)" id="15" localization="8" tooltip="" x="1049" y="442">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="24" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="24" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="24" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="24" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="24" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="24" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="24" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="24" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="24" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="24" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="24" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="24" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="around_the_ball (2)" id="16" localization="8" tooltip="" x="719" y="451">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_camera = 0
        self.head_angles = ["HeadYaw", "HeadPitch"]
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxsteptheta],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            nameID = None
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except (TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            #self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > 15):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def get_Pole_pixel(image):
            final_h = 0.0
            final_x = 0.0
            final_y = 0.0
            final_w = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                x, y, w, h = cv2.boundingRect(c)
                if(h > final_h):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            if(final_h < 120):
                return 0, 0
            else:
                return final_x + final_w/2.0, final_h + final_y
        def get_distance(image_x, image_y):
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            head_pitch = body_angles[1]
            if self.active_camera == 0:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.203680") - Decimal(str(image_y - 480.0))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.top_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = Decimal(str(image_x - 640.0)) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.top_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            elif self.active_camera == 1:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.86155206") - (Decimal(str(image_y)) - Decimal("480.0"))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.bottom_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = (Decimal(str(image_x)) - Decimal("640.0")) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.bottom_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            return distance_x , distance_y

        #置手部动作
        time.sleep(1)
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.1)

        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.active_camera = 0
            pole_x = 0.0
            pole_y = 0.0
            pole_flag = 0
            turn_flag = 0
            while(pole_x == 0.0 and pole_y == 0.0):
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    break
                head_yaw = (pole_flag/2) * 20 * math.pow(-1, int(math.fabs(pole_flag))) + 0.0
                if(head_yaw > 90):
                    head_yaw = 90
                    turn_flag = 1
                elif(head_yaw < -90):
                    head_yaw = -90
                    turn_flag = 0
                self.motion.setAngles(self.head_angles, [head_yaw/180.0*math.pi,0], 0.1)
                time.sleep(6)
                self.active_camera, image = get_Image(self.active_camera)
                pole_x, pole_y = get_Pole_pixel(image)
                self.output((pole_x, pole_y))
                if(turn_flag == 0):
                    pole_flag = pole_flag + 1
                elif(turn_flag == 1):
                    pole_flag = pole_flag - 1
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            turn_angle = int((-head_yaw / math.pi *180.0 + (pole_x - 640.0) / 1280.0 * 60 + 60) / 1.9)
            self.output(turn_angle)
            flag = 0

            if(turn_angle <= 20):
                self.motion.setAngles(self.head_angles, [0, 0], 0.1)
                self.motion.move(0,0,0.03, self.moveConfig)
                time.sleep(20)
                self.motion.move(0,0,0, self.moveConfig)
                while(1):
                    self.active_camera = 0
                    self.active_camera, image = get_Image(self.active_camera)
                    pole_x , pole_y = get_Pole_pixel(image)
                    if(pole_x != 0 and pole_x < 800):
                        break
                    self.motion.move(0.0,0.0,-0.03,self.moveConfig)
                    time.sleep(4)
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.onStopped()
                break
            elif(turn_angle > 20):
                turn_angle = 15
            #右手不动
            leftArmEnable  = True
            rightArmEnable = False
            self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)
            self.motion.setAngles(self.head_angles, [0, 0], 0.1)
            while(1):
                self.output(turn_angle)
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    self.motion.move(0.0, 0.0, 0.0, self.moveConfig)
                    self.stop_run()
                    break

                red_ball_x = 0.0
                red_ball_y = 0.0
                red_ball_radius = 0.0
                red_ball_distance_x = Decimal('0.0')
                red_ball_distance_y = Decimal('0.0')

                self.active_camera = 1
                self.active_camera, image = get_Image(self.active_camera)
                red_ball_x, red_ball_y = get_Redball_pixel(image)
                red_ball_distance_x, red_ball_distance_y = get_distance(red_ball_x, red_ball_y)
                turn_angle = turn_angle - 1
                if(red_ball_x ==0 and red_ball_y == 0):
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[-0.15, 0.0
    , 0], [0, 0, 0]], [0.3,0.3],False)
                    continue
                elif(red_ball_x > 1000):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0.0, 0.0
    , -0.15], [0, 0, 0]], [0.3,0.3],False)
                    continue
                control_x = 0.001
                control_y = 0.01
                control_theta = 0.03
                red_ball_distance_x = float(red_ball_distance_x)
                red_ball_distance_y = float(red_ball_distance_y)
                theta = math.atan(red_ball_distance_x/red_ball_distance_y)
                control_theta = control_theta + round(theta/0.1) * 0.003
                distance = math.sqrt(red_ball_distance_y*red_ball_distance_y + red_ball_distance_x*red_ball_distance_x)
                if(flag == 0):
                    expect_radius = distance
                    flag = 1
                diff_radius = distance - expect_radius
                control_x = control_x + round(diff_radius/5.0) * 0.001
                if(turn_angle > 0 and theta >= -0.2):
                    self.motion.move(control_x, control_y, -control_theta, self.moveConfig)
                elif(turn_angle > 0 and theta < -0.2):
                    self.motion.move(control_x, control_y, control_theta, self.moveConfig)
                else:
                    self.motion.move(0,0,0,self.moveConfig)
                    time.sleep(2)
                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="Bumpers_third" id="17" localization="8" tooltip="Listen to bumpers sensors. Stimulate onLeft or onRight output depending on&#x0A;which bumper is stimulated." x="191" y="439">
                            <bitmap>media/images/box/movement/move_foot.png</bitmap>
                            <bitmap>media/images/box/movement/move_leftfoot.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload()
            self.onStopped()]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Input name="LeftBumperPressed" type="0" type_size="1" nature="4" stm_value_name="LeftBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" />
                            <Input name="RightBumperPressed" type="0" type_size="1" nature="4" stm_value_name="RightBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="6" />
                            <Output name="onLeft" type="1" type_size="1" nature="2" inner="0" tooltip="When left bumper is stimulated." id="7" />
                            <Output name="onRight" type="1" type_size="1" nature="2" inner="0" tooltip="When right bumper is stimulated." id="8" />
                            <Timeline enable="0">
                                <BehaviorLayer name="behavior_layer1">
                                    <BehaviorKeyframe name="keyframe1" index="1">
                                        <Diagram>
                                            <Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="196" y="61">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Box name="If &gt; 0" id="4" localization="8" tooltip="Transmit only if value is &gt; 0." x="197" y="165">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="4" />
                                            <Link inputowner="0" indexofinput="7" outputowner="2" indexofoutput="3" />
                                            <Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="5" />
                                            <Link inputowner="0" indexofinput="8" outputowner="4" indexofoutput="3" />
                                        </Diagram>
                                    </BehaviorKeyframe>
                                </BehaviorLayer>
                            </Timeline>
                        </Box>
                        <Box name="firstHit (2)" id="20" localization="8" tooltip="" x="395" y="439">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="61">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="44" value="0" />
                                        <Key frame="61" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="44" value="-57.8135" />
                                        <Key frame="61" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="44" value="-79.1085" />
                                        <Key frame="61" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="44" value="0.257813" />
                                        <Key frame="61" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="44" value="80.7271" />
                                        <Key frame="61" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="61" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="44" value="0.228838" />
                                        <Key frame="61" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="44" value="47.7646" />
                                        <Key frame="61" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="44" value="116.9" />
                                        <Key frame="61" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="44" value="0" />
                                        <Key frame="61" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="61" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="44" value="69.6" />
                                        <Key frame="61" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="44" value="-3" />
                                        <Key frame="61" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="44" value="-32.4" />
                                        <Key frame="61" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="thirdHit " id="14" localization="8" tooltip="" x="923" y="608">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="18" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="18" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="18" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="18" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="18" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="18" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="18" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="18" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="18" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="18" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="around_the_ball (3)" id="21" localization="8" tooltip="" x="600" y="649">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_camera = 0
        self.head_angles = ["HeadYaw", "HeadPitch"]
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxsteptheta],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            nameID = None
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except (TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            #self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > 15):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def get_Pole_pixel(image):
            final_h = 0.0
            final_x = 0.0
            final_y = 0.0
            final_w = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                x, y, w, h = cv2.boundingRect(c)
                if(h > final_h):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            if(final_h < 120):
                return 0, 0
            else:
                return final_x + final_w/2.0, final_h + final_y
        def get_distance(image_x, image_y):
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            head_pitch = body_angles[1]
            if self.active_camera == 0:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.203680") - Decimal(str(image_y - 480.0))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.top_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = Decimal(str(image_x - 640.0)) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.top_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            elif self.active_camera == 1:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.86155206") - (Decimal(str(image_y)) - Decimal("480.0"))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.bottom_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = (Decimal(str(image_x)) - Decimal("640.0")) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.bottom_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            return distance_x , distance_y

        #置手部动作
        time.sleep(1)
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.1)

        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.active_camera = 0
            pole_x = 0.0
            pole_y = 0.0
            pole_flag = 0
            turn_flag = 0
            while(pole_x == 0.0 and pole_y == 0.0):
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    break
                head_yaw = (pole_flag/2) * 20 * math.pow(-1, int(math.fabs(pole_flag))) + 0.0
                if(head_yaw > 90):
                    head_yaw = 90
                    turn_flag = 1
                elif(head_yaw < -90):
                    head_yaw = -90
                    turn_flag = 0
                self.motion.setAngles(self.head_angles, [head_yaw/180.0*math.pi,0], 0.1)
                time.sleep(6)
                self.active_camera, image = get_Image(self.active_camera)
                pole_x, pole_y = get_Pole_pixel(image)
                self.output((pole_x, pole_y))
                if(turn_flag == 0):
                    pole_flag = pole_flag + 1
                elif(turn_flag == 1):
                    pole_flag = pole_flag - 1
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            turn_angle = int((-head_yaw / math.pi *180.0 + (pole_x - 640.0) / 1280.0 * 60 + 60) / 1.9)
            self.output(turn_angle)
            flag = 0

            if(turn_angle <= 20):
                self.motion.setAngles(self.head_angles, [0, 0], 0.1)
                self.motion.move(0,0,0.03, self.moveConfig)
                time.sleep(20)
                self.motion.move(0,0,0, self.moveConfig)
                while(1):
                    self.active_camera = 0
                    self.active_camera, image = get_Image(self.active_camera)
                    pole_x , pole_y = get_Pole_pixel(image)
                    if(pole_x != 0 and pole_x < 800):
                        break
                    self.motion.move(0.0,0.0,-0.03,self.moveConfig)
                    time.sleep(4)
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.onStopped()
                break
            elif(turn_angle > 20):
                turn_angle = 15
            #右手不动
            leftArmEnable  = True
            rightArmEnable = False
            self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)
            self.motion.setAngles(self.head_angles, [0, 0], 0.1)
            while(1):
                self.output(turn_angle)
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    self.motion.move(0.0, 0.0, 0.0, self.moveConfig)
                    self.stop_run()
                    break

                red_ball_x = 0.0
                red_ball_y = 0.0
                red_ball_radius = 0.0
                red_ball_distance_x = Decimal('0.0')
                red_ball_distance_y = Decimal('0.0')

                self.active_camera = 1
                self.active_camera, image = get_Image(self.active_camera)
                red_ball_x, red_ball_y = get_Redball_pixel(image)
                red_ball_distance_x, red_ball_distance_y = get_distance(red_ball_x, red_ball_y)
                turn_angle = turn_angle - 1
                if(red_ball_x ==0 and red_ball_y == 0):
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[-0.15, 0.0
    , 0], [0, 0, 0]], [0.3,0.3],False)
                    continue
                elif(red_ball_x > 1000):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0.0, 0.0
    , -0.15], [0, 0, 0]], [0.3,0.3],False)
                    continue
                control_x = 0.001
                control_y = 0.01
                control_theta = 0.03
                red_ball_distance_x = float(red_ball_distance_x)
                red_ball_distance_y = float(red_ball_distance_y)
                theta = math.atan(red_ball_distance_x/red_ball_distance_y)
                control_theta = control_theta + round(theta/0.1) * 0.003
                distance = math.sqrt(red_ball_distance_y*red_ball_distance_y + red_ball_distance_x*red_ball_distance_x)
                if(flag == 0):
                    expect_radius = distance
                    flag = 1
                diff_radius = distance - expect_radius
                control_x = control_x + round(diff_radius/5.0) * 0.001
                if(turn_angle > 0 and theta >= -0.2):
                    self.motion.move(control_x, control_y, -control_theta, self.moveConfig)
                elif(turn_angle > 0 and theta < -0.2):
                    self.motion.move(control_x, control_y, control_theta, self.moveConfig)
                else:
                    self.motion.move(0,0,0,self.moveConfig)
                    time.sleep(2)
                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="secondHit  (3)" id="4" localization="8" tooltip="" x="1354" y="304">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="18" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="18" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="18" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="18" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="18" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="18" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="18" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="18" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="18" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="18" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="18" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="around_the_ball (4)" id="24" localization="8" tooltip="" x="1506" y="138">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_camera = 0
        self.head_angles = ["HeadYaw", "HeadPitch"]
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxsteptheta],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            nameID = None
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except (TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            #self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > 20):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def get_Pole_pixel(image):
            final_h = 0.0
            final_x = 0.0
            final_y = 0.0
            final_w = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                x, y, w, h = cv2.boundingRect(c)
                if(h > final_h):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            if(final_h < 120):
                return 0, 0
            else:
                return final_x + final_w/2.0, final_h + final_y
        def get_distance(image_x, image_y):
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            head_pitch = body_angles[1]
            if self.active_camera == 0:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.203680") - Decimal(str(image_y - 480.0))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.top_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = Decimal(str(image_x - 640.0)) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.top_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            elif self.active_camera == 1:
                angle_y = Decimal(str(math.pi/2.0)) - Decimal("0.86155206") - (Decimal(str(image_y)) - Decimal("480.0"))/Decimal("960.0") * Decimal("0.831475") - Decimal(str(head_pitch))
                photo_distance_y = self.bottom_camera_height * Decimal(str(math.tan(angle_y)))
                angle_x = (Decimal(str(image_x)) - Decimal("640.0")) / Decimal("1280.0") * Decimal("1.064127")
                photo_distance_x = self.bottom_camera_height/Decimal(str(math.cos(angle_y)))*Decimal(str(math.tan(angle_x)))
                distance_y = photo_distance_y * Decimal(str(math.cos(head_yaw))) + photo_distance_x * Decimal(str(math.sin(head_yaw)))
                distance_x = photo_distance_x * Decimal(str(math.cos(head_yaw))) - photo_distance_y * Decimal(str(math.sin(head_yaw)))
            return distance_x , distance_y

        #置手部动作
        time.sleep(1)
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.1)

        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.active_camera = 0
            pole_x = 0.0
            pole_y = 0.0
            pole_flag = 0
            turn_flag = 0
            while(pole_x == 0.0 and pole_y == 0.0):
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    break
                head_yaw = (pole_flag/2) * 20 * math.pow(-1, int(math.fabs(pole_flag))) + 0.0
                if(head_yaw > 90):
                    head_yaw = 90
                    turn_flag = 1
                elif(head_yaw < -90):
                    head_yaw = -90
                    turn_flag = 0
                self.motion.setAngles(self.head_angles, [head_yaw/180.0*math.pi,0], 0.1)
                time.sleep(6)
                self.active_camera, image = get_Image(self.active_camera)
                pole_x, pole_y = get_Pole_pixel(image)
                self.output((pole_x, pole_y))
                if(turn_flag == 0):
                    pole_flag = pole_flag + 1
                elif(turn_flag == 1):
                    pole_flag = pole_flag - 1
            body_angles = self.motion.getAngles("Body", True)
            head_yaw   = body_angles[0]
            turn_angle = int((-head_yaw / math.pi *180.0 + (pole_x - 640.0) / 1280.0 * 60 + 60) / 1.9)
            self.output(turn_angle)
            flag = 0

            if(turn_angle <= 20):
                self.motion.setAngles(self.head_angles, [0, 0], 0.1)
                self.motion.move(0,0,0.03, self.moveConfig)
                time.sleep(20)
                self.motion.move(0,0,0, self.moveConfig)
                while(1):
                    self.active_camera = 0
                    self.active_camera, image = get_Image(self.active_camera)
                    pole_x , pole_y = get_Pole_pixel(image)
                    if(pole_x != 0 and pole_x < 800):
                        break
                    self.motion.move(0.0,0.0,-0.03,self.moveConfig)
                    time.sleep(4)
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.onStopped()
                break
            elif(turn_angle > 20):
                turn_angle = 15
            #右手不动
            leftArmEnable  = True
            rightArmEnable = False
            self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)
            self.motion.setAngles(self.head_angles, [0, 0], 0.1)
            while(1):
                self.output(turn_angle)
                if(self.memory.getData("FrontTactilTouched") == 1.0):
                    self.motion.move(0.0, 0.0, 0.0, self.moveConfig)
                    self.stop_run()
                    break

                red_ball_x = 0.0
                red_ball_y = 0.0
                red_ball_radius = 0.0
                red_ball_distance_x = Decimal('0.0')
                red_ball_distance_y = Decimal('0.0')

                self.active_camera = 1
                self.active_camera, image = get_Image(self.active_camera)
                red_ball_x, red_ball_y = get_Redball_pixel(image)
                red_ball_distance_x, red_ball_distance_y = get_distance(red_ball_x, red_ball_y)
                turn_angle = turn_angle - 1
                if(red_ball_x ==0 and red_ball_y == 0):
                    self.motion.move(0.0,0.0,0.0,self.moveConfig)
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[-0.15, 0.0
    , 0], [0, 0, 0]], [0.3,0.3],False)
                    continue
                elif(red_ball_x > 1000):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0.0, 0.0
    , -0.15], [0, 0, 0]], [0.3,0.3],False)
                    continue
                control_x = 0.001
                control_y = 0.01
                control_theta = 0.03
                red_ball_distance_x = float(red_ball_distance_x)
                red_ball_distance_y = float(red_ball_distance_y)
                theta = math.atan(red_ball_distance_x/red_ball_distance_y)
                control_theta = control_theta + round(theta/0.1) * 0.003
                distance = math.sqrt(red_ball_distance_y*red_ball_distance_y + red_ball_distance_x*red_ball_distance_x)
                if(flag == 0):
                    expect_radius = distance
                    flag = 1
                diff_radius = distance - expect_radius
                control_x = control_x + round(diff_radius/5.0) * 0.001
                if(turn_angle > 0 and theta >= -0.2):
                    self.motion.move(control_x, control_y, -control_theta, self.moveConfig)
                elif(turn_angle > 0 and theta < -0.2):
                    self.motion.move(control_x, control_y, control_theta, self.moveConfig)
                else:
                    self.motion.move(0,0,0,self.moveConfig)
                    time.sleep(2)
                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="go_to_ball   (1)" id="25" localization="8" tooltip="" x="1317" y="168">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import cv2
from PIL import Image
import vision_definitions
import numpy as np
import math
import time
import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.memory = ALProxy("ALMemory")

        self.head_angles = ['HeadYaw', 'HeadPitch']
        self.active_camera = 0

        maxstepx = 0.06
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.25
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                           ["MaxStepY", maxstepy],
                           ["MaxStepTheta", maxsteptheta],
                           ["MaxStepTheta",maxstepfrequency],
                           ["StepHeight", stepheight],
                           ["TorsoWx", torsowx],
                           ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > 10):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def one_Step( onestep_x, onestep_y, onestep_theta, onestep_count):
            onestep_X = onestep_x
            if onestep_theta == 0.0:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.04
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.04
            else:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.06
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.06
            onestep_Theta = onestep_theta
            onestep_Count = onestep_count
            lname = "LAnklePitch"
            lframe = 0
            leftFootPosition = self.motion.getPosition(lname, lframe, True)
            rname = "RAnklePitch"
            rframe = 0
            rightFootPosition = self.motion.getPosition(rname, rframe, True)
            stepDelta_x = leftFootPosition[0] - rightFootPosition[0]
            stepDelta_y = leftFootPosition[1] - rightFootPosition[1]
            if onestep_Theta == 0:
                if onestep_X > 0:
                    if stepDelta_x > 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x <=0 :
                        legName = ["LLeg", "RLeg"]
                elif onestep_X <= 0:
                    if stepDelta_x < 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x >=0:
                        legName = ["LLeg", "RLeg"]
            elif onestep_Theta > 0:
                legName = ["LLeg", "RLeg"]
            elif onestep_Theta < 0:
                legName = ["RLeg", "LLeg"]
            for i in range(0,onestep_Count):
                footSteps = [[onestep_X, onestep_Y, onestep_Theta], [onestep_X, -onestep_Y, onestep_Theta]]
                fractionMaxSpeed = [0.4, 0.4]
                clearExisting = False
                self.motion.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)
            self.motion.waitUntilMoveIsFinished()
            leftFootPosition_1 = self.motion.getPosition("LAnklePitch", 0, True)
            rightFootPosition_1 = self.motion.getPosition("RAnklePitch", 0, True)
            stepDelta_x_1 = leftFootPosition_1[0] - rightFootPosition_1[0]
            MaxSpeed = 0.2
            if (stepDelta_x_1 > 0):
                self.motion.setFootStepsWithSpeed(['RLeg'], [[0, 0, 0]], [MaxSpeed],False)
            elif (stepDelta_x_1 < 0):
                self.motion.setFootStepsWithSpeed(['LLeg'], [[0, 0, 0]], [MaxSpeed],False)
            time.sleep(0.1)
        def go_Right_angle(red_ball_x, red_ball_y):
            flag = 0
            if(self.active_camera == 0 and red_ball_y < 700):
                flag = 0
            elif(self.active_camera == 0 and red_ball_y >= 700):
                flag = 1
            elif(self.active_camera == 1):
                flag = 2
            pixel = ((580, 720), (530,770,), (600, 700))
            if red_ball_x <= pixel[flag][0]:
                if red_ball_x <= 400:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x <= 520:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x > 520:
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
            elif red_ball_x >= pixel[flag][1]:
                if red_ball_x >= 900:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x >= 780:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x < 780:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        self.motion.moveInit()
        self.motion.setAngles(self.head_angles, [0,0], 0.1)
        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0,0,0,self.moveConfig)
                self.stop_run()
                break
            red_ball_x = 0.0
            red_ball_y = 0.0
            self.active_camera, image = get_Image(self.active_camera)
            red_ball_x, red_ball_y = get_Redball_pixel(image)
            self.output((red_ball_x, red_ball_y))
            if(red_ball_x == 0 and red_ball_y == 0):
                continue
            if(self.active_camera == 0):
                if(red_ball_y < 700):
                    if(red_ball_x > 580 and red_ball_x < 720):
                        if red_ball_y < 650:
                            if red_ball_x > 620 and red_ball_x < 680:
                                self.motion.move(0.06,0, 0, self.moveConfig)
                                time.sleep(6)
                                self.motion.move(0,0,0,self.moveConfig)
                            else:
                                self.motion.move(0.06,0,0,self.moveConfig)
                                time.sleep(4)
                                self.motion.move(0,0,0,self.moveConfig)
                        elif red_ball_y >= 650 and red_ball_y <700:
                            self.motion.move(0.04,0.0,0.0,self.moveConfig)
                            time.sleep(4)
                            self.motion.move(0,0,0,self.moveConfig)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >=700 and red_ball_y < 800):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 700 and red_ball_y < 760:
                            one_Step(0.04,0,0,3)
                        elif red_ball_y >= 760 and red_ball_y <800:
                            one_Step(0.04,0,0,2)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >= 800 and red_ball_y < 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 800 and red_ball_y <= 830:
                            one_Step(0.03,0.0,0.0,2)
                        elif  red_ball_y >830 and red_ball_y <900:
                            one_Step(0.04,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif (red_ball_y >= 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        self.active_camera = 1
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
            elif(self.active_camera == 1):
                if(red_ball_y < 600):
                    if(red_ball_x > 600 and red_ball_x < 700):
                        if red_ball_y <200:
                            one_Step(0.04,0.0,0.0,3)
                        elif red_ball_y >= 200 and red_ball_y <330:
                            one_Step(0.03,0.0,0.0,3)
                        elif red_ball_y >= 330 and red_ball_y <500:
                            one_Step(0.03,0.0,0.0,2)
                        elif red_ball_y >= 500 and red_ball_y <600:
                            one_Step(0.03,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif red_ball_y >= 500:
                    if red_ball_x <= 500:
                        one_Step(0, 0, 3*math.pi/180,1)
                    elif red_ball_x >= 780:
                        one_Step(0, 0, -3*math.pi/180,1)
                    elif red_ball_x > 500 and red_ball_x <= 780:
                        self.onStopped()
                        break
            time.sleep(0.5)
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="firstHit (3)" id="27" localization="8" tooltip="" x="460" y="846">
                            <bitmap>media/images/box/box-timeLine.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="60" size="60">
                                <ActuatorList model="nao">
                                    <ActuatorCurve name="value" actuator="HeadPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="13.0056" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="HeadYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0" />
                                        <Key frame="14" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.778" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.524941" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-57.8135" />
                                        <Key frame="14" value="-57.8135" />
                                        <Key frame="50" value="-56.4241" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-79.1085" />
                                        <Key frame="14" value="-79.1085" />
                                        <Key frame="50" value="-77.5229" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0.0037582" />
                                        <Key frame="14" value="0.257813" />
                                        <Key frame="50" value="0.2288" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.3104" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.353968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.5489" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="80.7271" />
                                        <Key frame="14" value="80.7271" />
                                        <Key frame="50" value="82.7037" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="17.031" />
                                        <Key frame="50" value="15.2908" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="LWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="0.228838" />
                                        <Key frame="14" value="0.228838" />
                                        <Key frame="50" value="1.75543" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnklePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-19.6853" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RAnkleRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="0.529749" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="2.12968" />
                                        <Key frame="14" value="47.7646" />
                                        <Key frame="50" value="23.9968" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RElbowYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="119.393" />
                                        <Key frame="14" value="116.9" />
                                        <Key frame="50" value="117.773" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHand" recordable="0" mute="0" unit="1">
                                        <Key frame="13" value="0" />
                                        <Key frame="14" value="0" />
                                        <Key frame="50" value="0" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-25.5789" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.0854867" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RHipYawPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="-0.261268" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RKneePitch" recordable="0" mute="0" unit="0">
                                        <Key frame="50" value="39.6416" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderPitch" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="118.82" />
                                        <Key frame="14" value="69.6" />
                                        <Key frame="50" value="119.5" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RShoulderRoll" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-3.8" />
                                        <Key frame="14" value="-3" />
                                        <Key frame="50" value="-5.9" />
                                    </ActuatorCurve>
                                    <ActuatorCurve name="value" actuator="RWristYaw" recordable="0" mute="0" unit="0">
                                        <Key frame="13" value="-34.5" />
                                        <Key frame="14" value="-32.4" />
                                        <Key frame="50" value="-19.8659" />
                                    </ActuatorCurve>
                                </ActuatorList>
                            </Timeline>
                        </Box>
                        <Box name="Bumpers_first (1)" id="28" localization="8" tooltip="Listen to bumpers sensors. Stimulate onLeft or onRight output depending on&#x0A;which bumper is stimulated." x="236" y="699">
                            <bitmap>media/images/box/movement/move_foot.png</bitmap>
                            <bitmap>media/images/box/movement/move_leftfoot.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload()
            self.onStopped()]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Input name="LeftBumperPressed" type="0" type_size="1" nature="4" stm_value_name="LeftBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" />
                            <Input name="RightBumperPressed" type="0" type_size="1" nature="4" stm_value_name="RightBumperPressed" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="6" />
                            <Output name="onLeft" type="1" type_size="1" nature="2" inner="0" tooltip="When left bumper is stimulated." id="7" />
                            <Output name="onRight" type="1" type_size="1" nature="2" inner="0" tooltip="When right bumper is stimulated." id="8" />
                            <Timeline enable="0">
                                <BehaviorLayer name="behavior_layer1">
                                    <BehaviorKeyframe name="keyframe1" index="1">
                                        <Diagram>
                                            <Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="196" y="61">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Box name="If &gt; 0" id="4" localization="8" tooltip="Transmit only if value is &gt; 0." x="197" y="165">
                                                <bitmap>media/images/box/box-diagram.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="0" type_size="1" nature="1" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Output name="onStopped" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when box behavior is finished." id="3" />
                                            </Box>
                                            <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="4" />
                                            <Link inputowner="0" indexofinput="7" outputowner="2" indexofoutput="3" />
                                            <Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="5" />
                                            <Link inputowner="0" indexofinput="8" outputowner="4" indexofoutput="3" />
                                        </Diagram>
                                    </BehaviorKeyframe>
                                </BehaviorLayer>
                            </Timeline>
                        </Box>
                        <Box name="hit_ready   (1)" id="29" localization="8" tooltip="" x="1100" y="544">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import cv2.cv as cv
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_Camera = 0
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')
        self.head_angles = ["HeadYaw", "HeadPitch"]

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxstepy],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        #转换摄像头,参数:"Top", "Bottom"
        def select_Camera(camera_Name):
            if camera_Name == "Top":
                active_Camera = 0
            elif camera_Name == "Bottom":
                active_Camera = 1
            else:
                return 0
            self.device.setActiveCamera(active_Camera)
            nameID = self.device.subscribe("python_GA"+str(random.randint(100,100000)), vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            return active_Camera, nameID
        def get_Image(nameID):
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    img = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(img)
            return frame

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        #右手不动
        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        pole_x = 0.0
        pole_y = 0.0
        pole_distance_x = 0.0
        pole_distance_y = 0.0
        red_ball_x = 0.0
        red_ball_y = 0.0
        red_ball_distance_x = 0.0
        red_ball_distance_y = 0.0
        head_yaw_init = -30*math.pi/180
        head_pitch_init = 10*math.pi/180
        MaxSpeed = 0.3

        while(1):
            red_ball_x = 0.0
            red_ball_y = 0.0
            circles = None
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.motion.setAngles(self.head_angles, [head_yaw_init, head_pitch_init], 0.1)
            #获得电机角度
            body_angles = self.motion.getAngles("Body", True)
            head_yaw = Decimal((str)(body_angles[0]))
            head_pitch =Decimal((str)( body_angles[1]))
            #识别红球图像中位置
            self.active_Camera, nameID = select_Camera("Bottom")
            self.output(nameID)
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            img0 = cv2.Canny(hsv, 200, 300)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(img0, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if y > red_ball_y and radius > 20:
                    red_ball_y = y
                    red_ball_x = x
            self.output((red_ball_x, red_ball_y))
            time.sleep(0.1)

            red_ball_angle_y = Decimal((str)(math.pi/2.0)) - Decimal('0.86155206') - (Decimal((str)(red_ball_y)) - Decimal('480.0'))/Decimal('960.0') * Decimal('0.831475') - head_pitch
            red_ball_photo_distance_y = self.bottom_camera_height * Decimal((str)(math.tan(red_ball_angle_y)))
            red_ball_angle_x = (Decimal((str)(red_ball_x)) - Decimal('640.0')) / Decimal('1280.0') * Decimal('1.064127')
            red_ball_photo_distance_x = self.bottom_camera_height/Decimal((str)(math.cos(red_ball_angle_y)))*Decimal((str)(math.tan(red_ball_angle_x)))
            red_ball_distance_y = red_ball_photo_distance_y * Decimal((str)(math.cos(head_yaw))) + red_ball_photo_distance_x * Decimal((str)(math.sin(head_yaw)))
            red_ball_distance_x = red_ball_photo_distance_x * Decimal((str)(math.cos(head_yaw))) - red_ball_photo_distance_y * Decimal((str)(math.sin(head_yaw)))

            #识别杆的位置
            self.active_Camera, nameID = select_Camera("Top")
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            final_h = 0
            final_x = 0
            final_y = 0
            final_w = 0
            for c in contours:
                x,y,w,h = cv2.boundingRect(c)
                if(h>final_h and h > 120):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            pole_x = final_x + final_w / 2.0
            pole_y = final_y + final_h
            self.output((pole_x, pole_y))
            time.sleep(0.1)
            time.sleep(1)
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="go_to_ball   (2)" id="9" localization="8" tooltip="" x="581" y="329">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import cv2
from PIL import Image
import vision_definitions
import numpy as np
import math
import time
import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.memory = ALProxy("ALMemory")

        self.head_angles = ['HeadYaw', 'HeadPitch']
        self.active_camera = 0

        maxstepx = 0.06
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.25
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                           ["MaxStepY", maxstepy],
                           ["MaxStepTheta", maxsteptheta],
                           ["MaxStepTheta",maxstepfrequency],
                           ["StepHeight", stepheight],
                           ["TorsoWx", torsowx],
                           ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            if(self.active_camera == 0):
                min_radius = 5.0
            elif(self.active_camera == 1):
                min_radius = 15.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > min_radius):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def one_Step( onestep_x, onestep_y, onestep_theta, onestep_count):
            onestep_X = onestep_x
            if onestep_theta == 0.0:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.04
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.04
            else:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.06
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.06
            onestep_Theta = onestep_theta
            onestep_Count = onestep_count
            lname = "LAnklePitch"
            lframe = 0
            leftFootPosition = self.motion.getPosition(lname, lframe, True)
            rname = "RAnklePitch"
            rframe = 0
            rightFootPosition = self.motion.getPosition(rname, rframe, True)
            stepDelta_x = leftFootPosition[0] - rightFootPosition[0]
            stepDelta_y = leftFootPosition[1] - rightFootPosition[1]
            if onestep_Theta == 0:
                if onestep_X > 0:
                    if stepDelta_x > 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x <=0 :
                        legName = ["LLeg", "RLeg"]
                elif onestep_X <= 0:
                    if stepDelta_x < 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x >=0:
                        legName = ["LLeg", "RLeg"]
            elif onestep_Theta > 0:
                legName = ["LLeg", "RLeg"]
            elif onestep_Theta < 0:
                legName = ["RLeg", "LLeg"]
            for i in range(0,onestep_Count):
                footSteps = [[onestep_X, onestep_Y, onestep_Theta], [onestep_X, -onestep_Y, onestep_Theta]]
                fractionMaxSpeed = [0.4, 0.4]
                clearExisting = False
                self.motion.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)
            self.motion.waitUntilMoveIsFinished()
            leftFootPosition_1 = self.motion.getPosition("LAnklePitch", 0, True)
            rightFootPosition_1 = self.motion.getPosition("RAnklePitch", 0, True)
            stepDelta_x_1 = leftFootPosition_1[0] - rightFootPosition_1[0]
            MaxSpeed = 0.2
            if (stepDelta_x_1 > 0):
                self.motion.setFootStepsWithSpeed(['RLeg'], [[0, 0, 0]], [MaxSpeed],False)
            elif (stepDelta_x_1 < 0):
                self.motion.setFootStepsWithSpeed(['LLeg'], [[0, 0, 0]], [MaxSpeed],False)
            time.sleep(0.1)
        def go_Right_angle(red_ball_x, red_ball_y):
            flag = 0
            if(self.active_camera == 0 and red_ball_y < 700):
                flag = 0
            elif(self.active_camera == 0 and red_ball_y >= 700):
                flag = 1
            elif(self.active_camera == 1):
                flag = 2
            pixel = ((580, 720), (530,770,), (600, 700))
            if red_ball_x <= pixel[flag][0]:
                if red_ball_x <= 400:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x <= 520:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x > 520:
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
            elif red_ball_x >= pixel[flag][1]:
                if red_ball_x >= 900:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x >= 780:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x < 780:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        self.motion.moveInit()
        self.motion.setAngles(self.head_angles, [0,0], 0.1)
        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0,0,0,self.moveConfig)
                self.stop_run()
                break
            red_ball_x = 0.0
            red_ball_y = 0.0
            self.active_camera, image = get_Image(self.active_camera)
            red_ball_x, red_ball_y = get_Redball_pixel(image)
            self.output((red_ball_x, red_ball_y))
            if(red_ball_x == 0 and red_ball_y == 0):
                continue
            if(self.active_camera == 0):
                if(red_ball_y < 700):
                    if(red_ball_x > 580 and red_ball_x < 720):
                        if red_ball_y < 650:
                            if red_ball_x > 620 and red_ball_x < 680:
                                self.motion.move(0.06,0, 0, self.moveConfig)
                                time.sleep(6)
                                self.motion.move(0,0,0,self.moveConfig)
                            else:
                                self.motion.move(0.06,0,0,self.moveConfig)
                                time.sleep(4)
                                self.motion.move(0,0,0,self.moveConfig)
                        elif red_ball_y >= 650 and red_ball_y <700:
                            self.motion.move(0.04,0.0,0.0,self.moveConfig)
                            time.sleep(4)
                            self.motion.move(0,0,0,self.moveConfig)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >=700 and red_ball_y < 800):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 700 and red_ball_y < 760:
                            one_Step(0.04,0,0,3)
                        elif red_ball_y >= 760 and red_ball_y <800:
                            one_Step(0.04,0,0,2)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >= 800 and red_ball_y < 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 800 and red_ball_y <= 830:
                            one_Step(0.03,0.0,0.0,2)
                        elif  red_ball_y >830 and red_ball_y <900:
                            one_Step(0.04,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif (red_ball_y >= 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        self.active_camera = 1
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
            elif(self.active_camera == 1):
                if(red_ball_y < 600):
                    if(red_ball_x > 600 and red_ball_x < 700):
                        if red_ball_y <200:
                            one_Step(0.04,0.0,0.0,3)
                        elif red_ball_y >= 200 and red_ball_y <330:
                            one_Step(0.03,0.0,0.0,3)
                        elif red_ball_y >= 330 and red_ball_y <500:
                            one_Step(0.03,0.0,0.0,2)
                        elif red_ball_y >= 500 and red_ball_y <600:
                            one_Step(0.03,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif red_ball_y >= 500:
                    if red_ball_x <= 500:
                        one_Step(0, 0, 3*math.pi/180,1)
                    elif red_ball_x >= 780:
                        one_Step(0, 0, -3*math.pi/180,1)
                    elif red_ball_x > 500 and red_ball_x <= 780:
                        self.onStopped()
                        break
            time.sleep(0.5)
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="go_to_ball   (3)" id="11" localization="8" tooltip="" x="562" y="458">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import cv2
from PIL import Image
import vision_definitions
import numpy as np
import math
import time
import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.memory = ALProxy("ALMemory")

        self.head_angles = ['HeadYaw', 'HeadPitch']
        self.active_camera = 0

        maxstepx = 0.06
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.25
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                           ["MaxStepY", maxstepy],
                           ["MaxStepTheta", maxsteptheta],
                           ["MaxStepTheta",maxstepfrequency],
                           ["StepHeight", stepheight],
                           ["TorsoWx", torsowx],
                           ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            if(self.active_camera == 0):
                min_radius = 5.0
            elif(self.active_camera == 1):
                min_radius = 15.0
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > min_radius):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def one_Step( onestep_x, onestep_y, onestep_theta, onestep_count):
            onestep_X = onestep_x
            if onestep_theta == 0.0:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.04
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.04
            else:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.06
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.06
            onestep_Theta = onestep_theta
            onestep_Count = onestep_count
            lname = "LAnklePitch"
            lframe = 0
            leftFootPosition = self.motion.getPosition(lname, lframe, True)
            rname = "RAnklePitch"
            rframe = 0
            rightFootPosition = self.motion.getPosition(rname, rframe, True)
            stepDelta_x = leftFootPosition[0] - rightFootPosition[0]
            stepDelta_y = leftFootPosition[1] - rightFootPosition[1]
            if onestep_Theta == 0:
                if onestep_X > 0:
                    if stepDelta_x > 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x <=0 :
                        legName = ["LLeg", "RLeg"]
                elif onestep_X <= 0:
                    if stepDelta_x < 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x >=0:
                        legName = ["LLeg", "RLeg"]
            elif onestep_Theta > 0:
                legName = ["LLeg", "RLeg"]
            elif onestep_Theta < 0:
                legName = ["RLeg", "LLeg"]
            for i in range(0,onestep_Count):
                footSteps = [[onestep_X, onestep_Y, onestep_Theta], [onestep_X, -onestep_Y, onestep_Theta]]
                fractionMaxSpeed = [0.4, 0.4]
                clearExisting = False
                self.motion.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)
            self.motion.waitUntilMoveIsFinished()
            leftFootPosition_1 = self.motion.getPosition("LAnklePitch", 0, True)
            rightFootPosition_1 = self.motion.getPosition("RAnklePitch", 0, True)
            stepDelta_x_1 = leftFootPosition_1[0] - rightFootPosition_1[0]
            MaxSpeed = 0.2
            if (stepDelta_x_1 > 0):
                self.motion.setFootStepsWithSpeed(['RLeg'], [[0, 0, 0]], [MaxSpeed],False)
            elif (stepDelta_x_1 < 0):
                self.motion.setFootStepsWithSpeed(['LLeg'], [[0, 0, 0]], [MaxSpeed],False)
            time.sleep(0.1)
        def go_Right_angle(red_ball_x, red_ball_y):
            flag = 0
            if(self.active_camera == 0 and red_ball_y < 700):
                flag = 0
            elif(self.active_camera == 0 and red_ball_y >= 700):
                flag = 1
            elif(self.active_camera == 1):
                flag = 2
            pixel = ((580, 720), (530,770,), (600, 700))
            if red_ball_x <= pixel[flag][0]:
                if red_ball_x <= 400:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x <= 520:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x > 520:
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
            elif red_ball_x >= pixel[flag][1]:
                if red_ball_x >= 900:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x >= 780:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x < 780:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        self.motion.moveInit()
        self.motion.setAngles(self.head_angles, [0,0], 0.1)
        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0,0,0,self.moveConfig)
                self.stop_run()
                break
            red_ball_x = 0.0
            red_ball_y = 0.0
            self.active_camera, image = get_Image(self.active_camera)
            red_ball_x, red_ball_y = get_Redball_pixel(image)
            self.output((red_ball_x, red_ball_y))
            if(red_ball_x == 0 and red_ball_y == 0):
                continue
            if(self.active_camera == 0):
                if(red_ball_y < 700):
                    if(red_ball_x > 580 and red_ball_x < 720):
                        if red_ball_y < 650:
                            if red_ball_x > 620 and red_ball_x < 680:
                                self.motion.move(0.06,0, 0, self.moveConfig)
                                time.sleep(6)
                                self.motion.move(0,0,0,self.moveConfig)
                            else:
                                self.motion.move(0.06,0,0,self.moveConfig)
                                time.sleep(4)
                                self.motion.move(0,0,0,self.moveConfig)
                        elif red_ball_y >= 650 and red_ball_y <700:
                            self.motion.move(0.04,0.0,0.0,self.moveConfig)
                            time.sleep(4)
                            self.motion.move(0,0,0,self.moveConfig)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >=700 and red_ball_y < 800):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 700 and red_ball_y < 760:
                            one_Step(0.04,0,0,3)
                        elif red_ball_y >= 760 and red_ball_y <800:
                            one_Step(0.04,0,0,2)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >= 800 and red_ball_y < 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 800 and red_ball_y <= 830:
                            one_Step(0.03,0.0,0.0,2)
                        elif  red_ball_y >830 and red_ball_y <900:
                            one_Step(0.04,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif (red_ball_y >= 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        self.active_camera = 1
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
            elif(self.active_camera == 1):
                if(red_ball_y < 600):
                    if(red_ball_x > 600 and red_ball_x < 700):
                        if red_ball_y <200:
                            one_Step(0.04,0.0,0.0,3)
                        elif red_ball_y >= 200 and red_ball_y <330:
                            one_Step(0.03,0.0,0.0,3)
                        elif red_ball_y >= 330 and red_ball_y <500:
                            one_Step(0.03,0.0,0.0,2)
                        elif red_ball_y >= 500 and red_ball_y <600:
                            one_Step(0.03,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif red_ball_y >= 500:
                    if red_ball_x <= 500:
                        one_Step(0, 0, 3*math.pi/180,1)
                    elif red_ball_x >= 780:
                        one_Step(0, 0, -3*math.pi/180,1)
                    elif red_ball_x > 500 and red_ball_x <= 780:
                        self.onStopped()
                        break
            time.sleep(0.5)
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="go_to_ball   (4)" id="18" localization="8" tooltip="" x="455" y="603">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import cv2
from PIL import Image
import vision_definitions
import numpy as np
import math
import time
import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.memory = ALProxy("ALMemory")

        self.head_angles = ['HeadYaw', 'HeadPitch']
        self.active_camera = 0

        maxstepx = 0.06
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.25
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                           ["MaxStepY", maxstepy],
                           ["MaxStepTheta", maxsteptheta],
                           ["MaxStepTheta",maxstepfrequency],
                           ["StepHeight", stepheight],
                           ["TorsoWx", torsowx],
                           ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        def get_Image(active_camera):
            self.device.setActiveCamera(active_camera)
            handle = "camera_" + str(random.randint(1, 100000000))
            nameID = self.device.subscribe(handle, vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    image = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(image)
            self.device.unsubscribe(nameID)
            self.device.releaseImage(nameID)
            return active_camera, frame
        def get_Redball_pixel(image):
            image_x = 0.0
            image_y = 0.0
            image_radius = 0.0
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(hsv, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            if(self.active_camera == 0):
                min_radius = 5.0
            elif(self.active_camera == 1):
                min_radius = 15.0
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if(y > image_y and radius > min_radius):
                    image_y = y
                    image_x = x
                    image_radius = radius
            return image_x, image_y
        def one_Step( onestep_x, onestep_y, onestep_theta, onestep_count):
            onestep_X = onestep_x
            if onestep_theta == 0.0:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.04
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.04
            else:
                if onestep_y >= 0:
                    onestep_Y = onestep_y+0.06
                elif onestep_y < 0:
                    onestep_Y = onestep_y-0.06
            onestep_Theta = onestep_theta
            onestep_Count = onestep_count
            lname = "LAnklePitch"
            lframe = 0
            leftFootPosition = self.motion.getPosition(lname, lframe, True)
            rname = "RAnklePitch"
            rframe = 0
            rightFootPosition = self.motion.getPosition(rname, rframe, True)
            stepDelta_x = leftFootPosition[0] - rightFootPosition[0]
            stepDelta_y = leftFootPosition[1] - rightFootPosition[1]
            if onestep_Theta == 0:
                if onestep_X > 0:
                    if stepDelta_x > 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x <=0 :
                        legName = ["LLeg", "RLeg"]
                elif onestep_X <= 0:
                    if stepDelta_x < 0:
                        legName = ["RLeg", "LLeg"]
                    elif stepDelta_x >=0:
                        legName = ["LLeg", "RLeg"]
            elif onestep_Theta > 0:
                legName = ["LLeg", "RLeg"]
            elif onestep_Theta < 0:
                legName = ["RLeg", "LLeg"]
            for i in range(0,onestep_Count):
                footSteps = [[onestep_X, onestep_Y, onestep_Theta], [onestep_X, -onestep_Y, onestep_Theta]]
                fractionMaxSpeed = [0.4, 0.4]
                clearExisting = False
                self.motion.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)
            self.motion.waitUntilMoveIsFinished()
            leftFootPosition_1 = self.motion.getPosition("LAnklePitch", 0, True)
            rightFootPosition_1 = self.motion.getPosition("RAnklePitch", 0, True)
            stepDelta_x_1 = leftFootPosition_1[0] - rightFootPosition_1[0]
            MaxSpeed = 0.2
            if (stepDelta_x_1 > 0):
                self.motion.setFootStepsWithSpeed(['RLeg'], [[0, 0, 0]], [MaxSpeed],False)
            elif (stepDelta_x_1 < 0):
                self.motion.setFootStepsWithSpeed(['LLeg'], [[0, 0, 0]], [MaxSpeed],False)
            time.sleep(0.1)
        def go_Right_angle(red_ball_x, red_ball_y):
            flag = 0
            if(self.active_camera == 0 and red_ball_y < 700):
                flag = 0
            elif(self.active_camera == 0 and red_ball_y >= 700):
                flag = 1
            elif(self.active_camera == 1):
                flag = 2
            pixel = ((580, 720), (530,770,), (600, 700))
            if red_ball_x <= pixel[flag][0]:
                if red_ball_x <= 400:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x <= 520:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x > 520:
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0,0,0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
            elif red_ball_x >= pixel[flag][1]:
                if red_ball_x >= 900:
                    i = 3
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x >= 780:
                    i = 2
                    while i > 0:
                        self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                        self.motion.waitUntilMoveIsFinished()
                        i = i-1
                elif red_ball_x < 780:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        self.motion.moveInit()
        self.motion.setAngles(self.head_angles, [0,0], 0.1)
        while(1):
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0,0,0,self.moveConfig)
                self.stop_run()
                break
            red_ball_x = 0.0
            red_ball_y = 0.0
            self.active_camera, image = get_Image(self.active_camera)
            red_ball_x, red_ball_y = get_Redball_pixel(image)
            self.output((red_ball_x, red_ball_y))
            if(red_ball_x == 0 and red_ball_y == 0):
                continue
            if(self.active_camera == 0):
                if(red_ball_y < 700):
                    if(red_ball_x > 580 and red_ball_x < 720):
                        if red_ball_y < 650:
                            if red_ball_x > 620 and red_ball_x < 680:
                                self.motion.move(0.06,0, 0, self.moveConfig)
                                time.sleep(6)
                                self.motion.move(0,0,0,self.moveConfig)
                            else:
                                self.motion.move(0.06,0,0,self.moveConfig)
                                time.sleep(4)
                                self.motion.move(0,0,0,self.moveConfig)
                        elif red_ball_y >= 650 and red_ball_y <700:
                            self.motion.move(0.04,0.0,0.0,self.moveConfig)
                            time.sleep(4)
                            self.motion.move(0,0,0,self.moveConfig)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >=700 and red_ball_y < 800):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 700 and red_ball_y < 760:
                            one_Step(0.04,0,0,3)
                        elif red_ball_y >= 760 and red_ball_y <800:
                            one_Step(0.04,0,0,2)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif(red_ball_y >= 800 and red_ball_y < 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        if red_ball_y >= 800 and red_ball_y <= 830:
                            one_Step(0.03,0.0,0.0,2)
                        elif  red_ball_y >830 and red_ball_y <900:
                            one_Step(0.04,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif (red_ball_y >= 900):
                    if(red_ball_x > 530 and red_ball_x < 770):
                        self.active_camera = 1
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
            elif(self.active_camera == 1):
                if(red_ball_y < 600):
                    if(red_ball_x > 600 and red_ball_x < 700):
                        if red_ball_y <200:
                            one_Step(0.04,0.0,0.0,3)
                        elif red_ball_y >= 200 and red_ball_y <330:
                            one_Step(0.03,0.0,0.0,3)
                        elif red_ball_y >= 330 and red_ball_y <500:
                            one_Step(0.03,0.0,0.0,2)
                        elif red_ball_y >= 500 and red_ball_y <600:
                            one_Step(0.03,0.0,0.0,1)
                    else:
                        go_Right_angle(red_ball_x,red_ball_y)
                elif red_ball_y >= 500:
                    if red_ball_x <= 500:
                        one_Step(0, 0, 3*math.pi/180,1)
                    elif red_ball_x >= 780:
                        one_Step(0, 0, -3*math.pi/180,1)
                    elif red_ball_x > 500 and red_ball_x <= 780:
                        self.onStopped()
                        break
            time.sleep(0.5)
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="hit_ready   (2)" id="19" localization="8" tooltip="" x="895" y="322">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import cv2.cv as cv
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_Camera = 0
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')
        self.head_angles = ["HeadYaw", "HeadPitch"]

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxstepy],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        #转换摄像头,参数:"Top", "Bottom"
        def select_Camera(camera_Name):
            if camera_Name == "Top":
                active_Camera = 0
            elif camera_Name == "Bottom":
                active_Camera = 1
            else:
                return 0
            self.device.setActiveCamera(active_Camera)
            nameID = self.device.subscribe("python_GA"+str(random.randint(100,100000)), vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            return active_Camera, nameID
        def get_Image(nameID):
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    img = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(img)
            return frame

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        #右手不动
        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        pole_x = 0.0
        pole_y = 0.0
        pole_distance_x = 0.0
        pole_distance_y = 0.0
        red_ball_x = 0.0
        red_ball_y = 0.0
        red_ball_distance_x = 0.0
        red_ball_distance_y = 0.0
        head_yaw_init = -30*math.pi/180
        head_pitch_init = 10*math.pi/180
        MaxSpeed = 0.3

        while(1):
            red_ball_x = 0.0
            red_ball_y = 0.0
            circles = None
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.motion.setAngles(self.head_angles, [head_yaw_init, head_pitch_init], 0.1)
            #获得电机角度
            body_angles = self.motion.getAngles("Body", True)
            head_yaw = Decimal((str)(body_angles[0]))
            head_pitch =Decimal((str)( body_angles[1]))
            #识别红球图像中位置
            self.active_Camera, nameID = select_Camera("Bottom")
            self.output(nameID)
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            img0 = cv2.Canny(hsv, 200, 300)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(img0, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if y > red_ball_y and radius > 15:
                    red_ball_y = y
                    red_ball_x = x
            self.output((red_ball_x, red_ball_y))
            time.sleep(0.1)

            red_ball_angle_y = Decimal((str)(math.pi/2.0)) - Decimal('0.86155206') - (Decimal((str)(red_ball_y)) - Decimal('480.0'))/Decimal('960.0') * Decimal('0.831475') - head_pitch
            red_ball_photo_distance_y = self.bottom_camera_height * Decimal((str)(math.tan(red_ball_angle_y)))
            red_ball_angle_x = (Decimal((str)(red_ball_x)) - Decimal('640.0')) / Decimal('1280.0') * Decimal('1.064127')
            red_ball_photo_distance_x = self.bottom_camera_height/Decimal((str)(math.cos(red_ball_angle_y)))*Decimal((str)(math.tan(red_ball_angle_x)))
            red_ball_distance_y = red_ball_photo_distance_y * Decimal((str)(math.cos(head_yaw))) + red_ball_photo_distance_x * Decimal((str)(math.sin(head_yaw)))
            red_ball_distance_x = red_ball_photo_distance_x * Decimal((str)(math.cos(head_yaw))) - red_ball_photo_distance_y * Decimal((str)(math.sin(head_yaw)))

            #识别杆的位置
            self.active_Camera, nameID = select_Camera("Top")
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            final_h = 0
            final_x = 0
            final_y = 0
            final_w = 0
            for c in contours:
                x,y,w,h = cv2.boundingRect(c)
                if(h>final_h and h > 120):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            pole_x = final_x + final_w / 2.0
            pole_y = final_y + final_h
            self.output((pole_x, pole_y))
            time.sleep(0.1)

            if(red_ball_x == 0 and red_ball_y == 0):
                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(pole_x >550):
                i = 5
                while i > 0:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
                    i = i-1
            elif(red_ball_y <= 730 ):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y >= 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y > 730 and red_ball_y < 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.11
, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x <= 990):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.0, 0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(pole_x <= 30):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(3)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(pole_x < 100):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(2)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(red_ball_x< 1110 and red_ball_x > 990):
                    if(pole_y >= (1.8502 * pole_x +8.0086)):
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y <= (1.6596 * pole_x -110.4816)):
                        self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y > (1.6596 * pole_x -83.4816) and pole_y < (1.8502 * pole_x + 8.0086)):
                        if(red_ball_y <= 850):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >= 930):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >850 and red_ball_y <930):
                            if(red_ball_x >= 1065):
                                self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x <= 1000):
                                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0.11, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x > 1000 and red_ball_x <1065):
                                if(pole_y >= (1.7917 * pole_x -17.7646)):
                                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                elif(pole_y <= (1.7341 * pole_x -97.7361 )):
                                    self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                else:
                                    self.onStopped()
                                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="hit_ready   (3)" id="22" localization="8" tooltip="" x="891" y="453">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import cv2.cv as cv
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_Camera = 0
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')
        self.head_angles = ["HeadYaw", "HeadPitch"]

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxstepy],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        #转换摄像头,参数:"Top", "Bottom"
        def select_Camera(camera_Name):
            if camera_Name == "Top":
                active_Camera = 0
            elif camera_Name == "Bottom":
                active_Camera = 1
            else:
                return 0
            self.device.setActiveCamera(active_Camera)
            nameID = self.device.subscribe("python_GA"+str(random.randint(100,100000)), vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            return active_Camera, nameID
        def get_Image(nameID):
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    img = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(img)
            return frame

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        #右手不动
        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        pole_x = 0.0
        pole_y = 0.0
        pole_distance_x = 0.0
        pole_distance_y = 0.0
        red_ball_x = 0.0
        red_ball_y = 0.0
        red_ball_distance_x = 0.0
        red_ball_distance_y = 0.0
        head_yaw_init = -30*math.pi/180
        head_pitch_init = 10*math.pi/180
        MaxSpeed = 0.3

        while(1):
            red_ball_x = 0.0
            red_ball_y = 0.0
            circles = None
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.motion.setAngles(self.head_angles, [head_yaw_init, head_pitch_init], 0.1)
            #获得电机角度
            body_angles = self.motion.getAngles("Body", True)
            head_yaw = Decimal((str)(body_angles[0]))
            head_pitch =Decimal((str)( body_angles[1]))
            #识别红球图像中位置
            self.active_Camera, nameID = select_Camera("Bottom")
            self.output(nameID)
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            img0 = cv2.Canny(hsv, 200, 300)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(img0, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if y > red_ball_y and radius > 15:
                    red_ball_y = y
                    red_ball_x = x
            self.output((red_ball_x, red_ball_y))
            time.sleep(0.1)

            red_ball_angle_y = Decimal((str)(math.pi/2.0)) - Decimal('0.86155206') - (Decimal((str)(red_ball_y)) - Decimal('480.0'))/Decimal('960.0') * Decimal('0.831475') - head_pitch
            red_ball_photo_distance_y = self.bottom_camera_height * Decimal((str)(math.tan(red_ball_angle_y)))
            red_ball_angle_x = (Decimal((str)(red_ball_x)) - Decimal('640.0')) / Decimal('1280.0') * Decimal('1.064127')
            red_ball_photo_distance_x = self.bottom_camera_height/Decimal((str)(math.cos(red_ball_angle_y)))*Decimal((str)(math.tan(red_ball_angle_x)))
            red_ball_distance_y = red_ball_photo_distance_y * Decimal((str)(math.cos(head_yaw))) + red_ball_photo_distance_x * Decimal((str)(math.sin(head_yaw)))
            red_ball_distance_x = red_ball_photo_distance_x * Decimal((str)(math.cos(head_yaw))) - red_ball_photo_distance_y * Decimal((str)(math.sin(head_yaw)))

            #识别杆的位置
            self.active_Camera, nameID = select_Camera("Top")
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            final_h = 0
            final_x = 0
            final_y = 0
            final_w = 0
            for c in contours:
                x,y,w,h = cv2.boundingRect(c)
                if(h>final_h and h > 120):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            pole_x = final_x + final_w / 2.0
            pole_y = final_y + final_h
            self.output((pole_x, pole_y))
            time.sleep(0.1)

            if(red_ball_x == 0 and red_ball_y == 0):
                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(pole_x >550):
                i = 5
                while i > 0:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
                    i = i-1
            elif(red_ball_y <= 730 ):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y >= 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y > 730 and red_ball_y < 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.11
, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x <= 990):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.0, 0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(pole_x <= 30):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(3)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(pole_x < 100):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(2)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(red_ball_x< 1110 and red_ball_x > 990):
                    if(pole_y >= (1.8502 * pole_x +8.0086)):
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y <= (1.6596 * pole_x -110.4816)):
                        self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y > (1.6596 * pole_x -83.4816) and pole_y < (1.8502 * pole_x + 8.0086)):
                        if(red_ball_y <= 850):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >= 930):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >850 and red_ball_y <930):
                            if(red_ball_x >= 1065):
                                self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x <= 1000):
                                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0.11, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x > 1000 and red_ball_x <1065):
                                if(pole_y >= (1.7917 * pole_x -17.7646)):
                                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                elif(pole_y <= (1.7341 * pole_x -97.7361 )):
                                    self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                else:
                                    self.onStopped()
                                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="hit_ready   (4)" id="23" localization="8" tooltip="" x="763" y="613">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import cv2.cv as cv
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_Camera = 0
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')
        self.head_angles = ["HeadYaw", "HeadPitch"]

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxstepy],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        #转换摄像头,参数:"Top", "Bottom"
        def select_Camera(camera_Name):
            if camera_Name == "Top":
                active_Camera = 0
            elif camera_Name == "Bottom":
                active_Camera = 1
            else:
                return 0
            self.device.setActiveCamera(active_Camera)
            nameID = self.device.subscribe("python_GA"+str(random.randint(100,100000)), vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            return active_Camera, nameID
        def get_Image(nameID):
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    img = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(img)
            return frame

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        #右手不动
        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        pole_x = 0.0
        pole_y = 0.0
        pole_distance_x = 0.0
        pole_distance_y = 0.0
        red_ball_x = 0.0
        red_ball_y = 0.0
        red_ball_distance_x = 0.0
        red_ball_distance_y = 0.0
        head_yaw_init = -30*math.pi/180
        head_pitch_init = 10*math.pi/180
        MaxSpeed = 0.3

        while(1):
            red_ball_x = 0.0
            red_ball_y = 0.0
            circles = None
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.motion.setAngles(self.head_angles, [head_yaw_init, head_pitch_init], 0.1)
            #获得电机角度
            body_angles = self.motion.getAngles("Body", True)
            head_yaw = Decimal((str)(body_angles[0]))
            head_pitch =Decimal((str)( body_angles[1]))
            #识别红球图像中位置
            self.active_Camera, nameID = select_Camera("Bottom")
            self.output(nameID)
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            img0 = cv2.Canny(hsv, 200, 300)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(img0, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if y > red_ball_y and radius > 15:
                    red_ball_y = y
                    red_ball_x = x
            self.output((red_ball_x, red_ball_y))
            time.sleep(0.1)

            red_ball_angle_y = Decimal((str)(math.pi/2.0)) - Decimal('0.86155206') - (Decimal((str)(red_ball_y)) - Decimal('480.0'))/Decimal('960.0') * Decimal('0.831475') - head_pitch
            red_ball_photo_distance_y = self.bottom_camera_height * Decimal((str)(math.tan(red_ball_angle_y)))
            red_ball_angle_x = (Decimal((str)(red_ball_x)) - Decimal('640.0')) / Decimal('1280.0') * Decimal('1.064127')
            red_ball_photo_distance_x = self.bottom_camera_height/Decimal((str)(math.cos(red_ball_angle_y)))*Decimal((str)(math.tan(red_ball_angle_x)))
            red_ball_distance_y = red_ball_photo_distance_y * Decimal((str)(math.cos(head_yaw))) + red_ball_photo_distance_x * Decimal((str)(math.sin(head_yaw)))
            red_ball_distance_x = red_ball_photo_distance_x * Decimal((str)(math.cos(head_yaw))) - red_ball_photo_distance_y * Decimal((str)(math.sin(head_yaw)))

            #识别杆的位置
            self.active_Camera, nameID = select_Camera("Top")
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            final_h = 0
            final_x = 0
            final_y = 0
            final_w = 0
            for c in contours:
                x,y,w,h = cv2.boundingRect(c)
                if(h>final_h and h > 120):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            pole_x = final_x + final_w / 2.0
            pole_y = final_y + final_h
            self.output((pole_x, pole_y))
            time.sleep(0.1)

            if(red_ball_x == 0 and red_ball_y == 0):
                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(pole_x >550):
                i = 5
                while i > 0:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
                    i = i-1
            elif(red_ball_y <= 730 ):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y >= 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y > 730 and red_ball_y < 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.11
, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x <= 990):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.0, 0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(pole_x <= 30):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(3)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(pole_x < 100):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(2)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(red_ball_x< 1110 and red_ball_x > 990):
                    if(pole_y >= (1.8502 * pole_x +8.0086)):
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y <= (1.6596 * pole_x -110.4816)):
                        self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y > (1.6596 * pole_x -83.4816) and pole_y < (1.8502 * pole_x + 8.0086)):
                        if(red_ball_y <= 850):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >= 930):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >850 and red_ball_y <930):
                            if(red_ball_x >= 1065):
                                self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x <= 1000):
                                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0.11, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x > 1000 and red_ball_x <1065):
                                if(pole_y >= (1.7917 * pole_x -17.7646)):
                                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                elif(pole_y <= (1.7341 * pole_x -97.7361 )):
                                    self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                else:
                                    self.onStopped()
                                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Box name="hit_ready   (5)" id="26" localization="8" tooltip="" x="1674" y="165">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[from PIL import Image
from decimal import Decimal
import vision_definitions
import numpy as np
import cv2
import cv2.cv as cv
import random
import math
import time

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")
        self.device = ALProxy("ALVideoDevice")
        self.posture = ALProxy("ALRobotPosture")
        self.memory = ALProxy("ALMemory")

        self.active_Camera = 0
        self.top_camera_height = Decimal('50.0')
        self.bottom_camera_height = Decimal('45.5')
        self.head_angles = ["HeadYaw", "HeadPitch"]

        maxstepx = 0.04
        maxstepy = 0.14
        maxsteptheta = 0.4
        maxstepfrequency = 0.5
        stepheight = 0.02
        torsowx = 0.0
        torsowy = 0.0
        self.moveConfig = [["MaxStepX", maxstepx],
                      ["MaxStepY", maxstepy],
                      ["MaxStepTheta", maxstepy],
                      ["MaxStepFrequency", maxstepfrequency],
                      ["StepHeight", stepheight],
                      ["TorsoWx", torsowx],
                      ["TorsoWy", torsowy]]
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        #转换摄像头,参数:"Top", "Bottom"
        def select_Camera(camera_Name):
            if camera_Name == "Top":
                active_Camera = 0
            elif camera_Name == "Bottom":
                active_Camera = 1
            else:
                return 0
            self.device.setActiveCamera(active_Camera)
            nameID = self.device.subscribe("python_GA"+str(random.randint(100,100000)), vision_definitions.k4VGA, vision_definitions.kBGRColorSpace, 30)
            self.device.setCamerasParameter(nameID, 22, 2)
            return active_Camera, nameID
        def get_Image(nameID):
            while(1):
                try:
                    naoImage = self.device.getImageRemote(nameID)
                    imageWidth = naoImage[0]
                    imageHeight = naoImage[1]
                    array = naoImage[6]
                    img = Image.fromstring("RGB", (imageWidth, imageHeight), array)
                    break
                except(TypeError, ValueError):
                    continue
            frame = np.asarray(img)
            return frame

        #置手部动作
        setRhand_Angle_names  = ["RShoulderPitch","RShoulderRoll","RElbowRoll","RElbowYaw","RWristYaw"]
        setRhand_angles  = [115*math.pi/180,-30*math.pi/180,15*math.pi/180,100*math.pi/180,65*math.pi/180]
        setRhand_fractionMaxSpeed  = 0.1
        self.motion.setAngles(setRhand_Angle_names, setRhand_angles, setRhand_fractionMaxSpeed)
        time.sleep(0.5)

        #右手不动
        leftArmEnable  = True
        rightArmEnable = False
        self.motion.setMoveArmsEnabled(leftArmEnable, rightArmEnable)

        pole_x = 0.0
        pole_y = 0.0
        pole_distance_x = 0.0
        pole_distance_y = 0.0
        red_ball_x = 0.0
        red_ball_y = 0.0
        red_ball_distance_x = 0.0
        red_ball_distance_y = 0.0
        head_yaw_init = -30*math.pi/180
        head_pitch_init = 10*math.pi/180
        MaxSpeed = 0.3

        while(1):
            red_ball_x = 0.0
            red_ball_y = 0.0
            circles = None
            if(self.memory.getData("FrontTactilTouched") == 1.0):
                self.motion.move(0.0,0.0,0.0,self.moveConfig)
                self.stop_run()
                break
            self.motion.setAngles(self.head_angles, [head_yaw_init, head_pitch_init], 0.1)
            #获得电机角度
            body_angles = self.motion.getAngles("Body", True)
            head_yaw = Decimal((str)(body_angles[0]))
            head_pitch =Decimal((str)( body_angles[1]))
            #识别红球图像中位置
            self.active_Camera, nameID = select_Camera("Bottom")
            self.output(nameID)
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([0, 123, 100])
            high_range = np.array([5, 255, 255])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            img0 = cv2.Canny(hsv, 200, 300)
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
            dilated = cv2.dilate(img0, kernel)
            contours, hierarchy = cv2.findContours(dilated, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            for c in contours:
                (x, y), radius = cv2.minEnclosingCircle(c)
                if y > red_ball_y and radius > 20:
                    red_ball_y = y
                    red_ball_x = x
            self.output((red_ball_x, red_ball_y))
            time.sleep(0.1)

            red_ball_angle_y = Decimal((str)(math.pi/2.0)) - Decimal('0.86155206') - (Decimal((str)(red_ball_y)) - Decimal('480.0'))/Decimal('960.0') * Decimal('0.831475') - head_pitch
            red_ball_photo_distance_y = self.bottom_camera_height * Decimal((str)(math.tan(red_ball_angle_y)))
            red_ball_angle_x = (Decimal((str)(red_ball_x)) - Decimal('640.0')) / Decimal('1280.0') * Decimal('1.064127')
            red_ball_photo_distance_x = self.bottom_camera_height/Decimal((str)(math.cos(red_ball_angle_y)))*Decimal((str)(math.tan(red_ball_angle_x)))
            red_ball_distance_y = red_ball_photo_distance_y * Decimal((str)(math.cos(head_yaw))) + red_ball_photo_distance_x * Decimal((str)(math.sin(head_yaw)))
            red_ball_distance_x = red_ball_photo_distance_x * Decimal((str)(math.cos(head_yaw))) - red_ball_photo_distance_y * Decimal((str)(math.sin(head_yaw)))

            #识别杆的位置
            self.active_Camera, nameID = select_Camera("Top")
            image = get_Image(nameID)
            hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
            low_range = np.array([19, 117, 100])
            high_range = np.array([50, 255, 225])
            hsv = cv2.inRange(hsv_image, low_range, high_range)
            kernel = np.ones((10,50), np.uint8)
            closed = cv2.morphologyEx(hsv, cv2.MORPH_CLOSE, kernel)
            contours, hierarchy = cv2.findContours(closed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            final_h = 0
            final_x = 0
            final_y = 0
            final_w = 0
            for c in contours:
                x,y,w,h = cv2.boundingRect(c)
                if(h>final_h and h > 120):
                    final_h = h
                    final_x = x
                    final_y = y
                    final_w = w
            pole_x = final_x + final_w / 2.0
            pole_y = final_y + final_h
            self.output((pole_x, pole_y))
            time.sleep(0.1)

            if(red_ball_x == 0 and red_ball_y == 0):
                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(pole_x >550):
                i = 5
                while i > 0:
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0,0,-0.05], [0,0,0]], [0.2,0.2], False)
                    self.motion.waitUntilMoveIsFinished()
                    i = i-1
            elif(red_ball_y <= 730 ):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y >= 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.14, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x < 1100 and red_ball_x > 0):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.03, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
            elif(red_ball_y > 730 and red_ball_y < 910):
                if(red_ball_x >= 1100):
                    self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.11
, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(red_ball_x <= 990):
                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.0, 0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                elif(pole_x <= 30):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(3)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(pole_x < 100):
                    self.motion.move(0,0,0.03,self.moveConfig)
                    time.sleep(2)
                    self.motion.move(0,0,0,self.moveConfig)
                elif(red_ball_x< 1110 and red_ball_x > 990):
                    if(pole_y >= (1.8502 * pole_x +8.0086)):
                        self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y <= (1.6596 * pole_x -110.4816)):
                        self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                    elif(pole_y > (1.6596 * pole_x -83.4816) and pole_y < (1.8502 * pole_x + 8.0086)):
                        if(red_ball_y <= 850):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >= 930):
                            self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[-0.02, 0, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                        elif(red_ball_y >850 and red_ball_y <930):
                            if(red_ball_x >= 1065):
                                self.motion.setFootStepsWithSpeed(['RLeg', 'LLeg'], [[0, -0.12, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x <= 1000):
                                self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0.11, 0], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                            elif(red_ball_x > 1000 and red_ball_x <1065):
                                if(pole_y >= (1.7917 * pole_x -17.7646)):
                                    self.motion.setFootStepsWithSpeed(['LLeg', 'RLeg'], [[0, 0, 2*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                elif(pole_y <= (1.7341 * pole_x -97.7361 )):
                                    self.motion.setFootStepsWithSpeed(['RLeg' , 'LLeg'], [[0, 0, -4*math.pi/180], [0, 0, 0]], [MaxSpeed,MaxSpeed],False)
                                else:
                                    self.onStopped()
                                    break
        pass

    def onInput_onStop(self):
        self.stop_run()
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
                            <Output name="output" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" />
                            <Output name="stop_run" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" />
                        </Box>
                        <Link inputowner="12" indexofinput="2" outputowner="3" indexofoutput="7" />
                        <Link inputowner="12" indexofinput="2" outputowner="3" indexofoutput="8" />
                        <Link inputowner="1" indexofinput="2" outputowner="10" indexofoutput="4" />
                        <Link inputowner="10" indexofinput="2" outputowner="2" indexofoutput="4" />
                        <Link inputowner="13" indexofinput="2" outputowner="7" indexofoutput="7" />
                        <Link inputowner="13" indexofinput="2" outputowner="7" indexofoutput="8" />
                        <Link inputowner="20" indexofinput="2" outputowner="17" indexofoutput="7" />
                        <Link inputowner="20" indexofinput="2" outputowner="17" indexofoutput="8" />
                        <Link inputowner="2" indexofinput="2" outputowner="8" indexofoutput="4" />
                        <Link inputowner="8" indexofinput="2" outputowner="12" indexofoutput="4" />
                        <Link inputowner="24" indexofinput="2" outputowner="25" indexofoutput="4" />
                        <Link inputowner="25" indexofinput="2" outputowner="4" indexofoutput="4" />
                        <Link inputowner="27" indexofinput="2" outputowner="28" indexofoutput="7" />
                        <Link inputowner="27" indexofinput="2" outputowner="28" indexofoutput="8" />
                        <Link inputowner="11" indexofinput="2" outputowner="20" indexofoutput="4" />
                        <Link inputowner="16" indexofinput="2" outputowner="11" indexofoutput="4" />
                        <Link inputowner="9" indexofinput="2" outputowner="13" indexofoutput="4" />
                        <Link inputowner="6" indexofinput="2" outputowner="9" indexofoutput="4" />
                        <Link inputowner="19" indexofinput="2" outputowner="6" indexofoutput="4" />
                        <Link inputowner="5" indexofinput="2" outputowner="19" indexofoutput="4" />
                        <Link inputowner="22" indexofinput="2" outputowner="16" indexofoutput="4" />
                        <Link inputowner="15" indexofinput="2" outputowner="22" indexofoutput="4" />
                        <Link inputowner="18" indexofinput="2" outputowner="15" indexofoutput="4" />
                        <Link inputowner="21" indexofinput="2" outputowner="18" indexofoutput="4" />
                        <Link inputowner="23" indexofinput="2" outputowner="21" indexofoutput="4" />
                        <Link inputowner="14" indexofinput="2" outputowner="23" indexofoutput="4" />
                        <Link inputowner="26" indexofinput="2" outputowner="24" indexofoutput="4" />
                        <Link inputowner="4" indexofinput="2" outputowner="26" indexofoutput="4" />
                        <Link inputowner="17" indexofinput="2" outputowner="0" indexofoutput="2" />
                    </Diagram>
                </BehaviorKeyframe>
            </BehaviorLayer>
        </Timeline>
    </Box>
</ChoregrapheProject>
